using pc2u202114643.API.SCM.Domain.Model.Commands;
using pc2u202114643.API.SCM.Domain.Model.Enumerations;
using pc2u202114643.API.SCM.Domain.Model.ValueObjects;

namespace pc2u202114643.API.SCM.Domain.Model.Aggregates;

/// <summary>
///     Dispatch Order aggregate root that encapsulates the rules defined by DFC.
///     <author>u202114643</author>
/// </summary>
public partial class DispatchOrder
{
    private const int MinimumAllowedUnits = 100;
    private const int MaximumAllowedUnits = 5000;

    /// <summary>
    ///     Initializes a new instance of the <see cref="DispatchOrder" /> class for Entity Framework.
    /// </summary>
    protected DispatchOrder()
    {
        DispatchOrderId = null!;
        ProductId = null!;
    }

    /// <summary>
    ///     Initializes a new instance of the <see cref="DispatchOrder" /> class using the provided command.
    /// </summary>
    /// <param name="command">Command with all data required to register the dispatch order.</param>
    public DispatchOrder(CreateDispatchOrderCommand command)
    {
        DispatchOrderId = DispatchOrderId.New();
        ProductId = new ProductId(command.ProductId);
        RequestedUnits = ValidateRequestedUnits(command.RequestedUnits);

        DispatchExpectedAt = ValidateDispatchExpectedAt(command.DispatchExpectedAt);
        DispatchCompletedAt = ValidateCompletedAt(command.DispatchCompletedAt, DispatchExpectedAt);
        QualityLevel = DetermineQualityLevel((DispatchCompletedAt.Date - DispatchExpectedAt.Date).Days);
        Notes = command.Notes;
    }

    /// <summary>
    ///     Gets the numeric identifier generated by the persistence store.
    /// </summary>
    public int Id { get; private set; }

    /// <summary>
    ///     Gets the business identifier of the dispatch order.
    /// </summary>
    public DispatchOrderId DispatchOrderId { get; private set; }

    /// <summary>
    ///     Gets the product identifier provided by the Product bounded context.
    /// </summary>
    public ProductId ProductId { get; private set; }

    /// <summary>
    ///     Gets the requested units.
    /// </summary>
    public int RequestedUnits { get; private set; }

    /// <summary>
    ///     Gets the expected dispatch date (UTC).
    /// </summary>
    public DateTime DispatchExpectedAt { get; private set; }

    /// <summary>
    ///     Gets the completed dispatch date (UTC).
    /// </summary>
    public DateTime DispatchCompletedAt { get; private set; }

    /// <summary>
    ///     Gets the quality level assigned internally according to the domain rules.
    /// </summary>
    public EQualityLevel QualityLevel { get; private set; }

    /// <summary>
    ///     Gets the optional notes.
    /// </summary>
    public string? Notes { get; private set; }

    /// <summary>
    ///     Gets the number of days between the expected and the completed dates.
    /// </summary>
    public int DispatchDays => (DispatchCompletedAt.Date - DispatchExpectedAt.Date).Days;

    private static int ValidateRequestedUnits(int requestedUnits)
    {
        if (requestedUnits <= MinimumAllowedUnits)
            throw new ArgumentException("Requested units must be greater than 100.");
        if (requestedUnits > MaximumAllowedUnits)
            throw new ArgumentException("Requested units cannot exceed 5000.");
        return requestedUnits;
    }

    private static DateTime ValidateDispatchExpectedAt(DateTime dispatchExpectedAt)
    {
        var normalized = DateTime.SpecifyKind(dispatchExpectedAt, DateTimeKind.Utc);
        var maximumAllowed = DateTime.UtcNow.AddDays(-30);
        if (normalized > maximumAllowed)
            throw new ArgumentException("Dispatch expected date must be at least 30 days before the current date.");
        return normalized;
    }

    private static DateTime ValidateCompletedAt(DateTime dispatchCompletedAt, DateTime dispatchExpectedAt)
    {
        var normalized = DateTime.SpecifyKind(dispatchCompletedAt, DateTimeKind.Utc);
        if (normalized < dispatchExpectedAt)
            throw new ArgumentException("Dispatch completed date must be greater than or equal to the expected date.");
        return normalized;
    }

    private static EQualityLevel DetermineQualityLevel(int delayDays)
    {
        if (delayDays > 7) return EQualityLevel.Inefficient;
        if (delayDays > 5) return EQualityLevel.BellowExpected;
        if (delayDays > 2) return EQualityLevel.Normal;
        return EQualityLevel.Outstanding;
    }
}
